<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vollic</title>
  
  <subtitle>A Better Tomorrow</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://vollic.github.io/"/>
  <updated>2020-02-27T14:56:11.456Z</updated>
  <id>https://vollic.github.io/</id>
  
  <author>
    <name>Vollic</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入gRPC-01：概念篇</title>
    <link href="https://vollic.github.io/category/%E5%BE%AE%E6%9C%8D%E5%8A%A1/RPC/gRPC/%E6%B7%B1%E5%85%A5gRPC-01%EF%BC%9A%E6%A6%82%E5%BF%B5%E7%AF%87/"/>
    <id>https://vollic.github.io/category/%E5%BE%AE%E6%9C%8D%E5%8A%A1/RPC/gRPC/%E6%B7%B1%E5%85%A5gRPC-01%EF%BC%9A%E6%A6%82%E5%BF%B5%E7%AF%87/</id>
    <published>2020-02-27T14:56:03.000Z</published>
    <updated>2020-02-27T14:56:11.456Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>  RPC（Remote Procedure Call）远程过程调用，像调用本地方法一样调用远程方法，例如A,B两台服务器，A想要调用B服务器上的一个方法，但是两个服务器不在同一内存空间，只能通过网络表达调用B服务器方法的语义和调用的参数数据，常见的rpc框架<code>SpringCloud</code>,<code>Dubbo</code>,<code>gRPC</code></p><h3 id="远程调用过程"><a href="#远程调用过程" class="headerlink" title="远程调用过程"></a>远程调用过程</h3><p><img src="https://dubbo.apache.org/img/blog/rpc/rpc-work-principle.png" alt=""></p><p>RPC是一个CS模型，上图执行的步骤如下</p><ol><li>客户端Client无感知调用类似调用本地服务来调用远程方法</li><li>ClientStub接受到调用后将方法和参数序列化</li><li>ClientStub 通过sockets将消息发送到服务端</li><li>ServerStub接收到消息后将反序列化</li><li>ServerStub根据解码结果调用本地的服务</li><li>服务端的方法将执行并将结果返回给ServerStub</li><li>ServerStub将结果消息序列化</li><li>服务端通过Socket将结果传输给客户端</li><li>ClientStub接受到消息后将消息反序列化</li><li>客户端得到远程方法执行的结果</li></ol><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="之前业务痛点"><a href="#之前业务痛点" class="headerlink" title="之前业务痛点"></a>之前业务痛点</h4><ul><li>随着业务的扩张，系统的负载增加，难以水平扩展</li><li>系统整体依赖严重，系统某个模块出bug会影响整体系统</li><li>整个系统臃肿，严重影响迭代周期，其中某个功能滞后导致整个系统发布周期延后</li><li>系统整体的部署运维成本高，例如以前公司系统出包升级一次需要4个小时，现在服务拆分后结合容器，目前几分钟即可发布上线</li><li>系统技术严重绑定必须采用相同的技术栈，对于新技术引入困难</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>服务之间的解耦，服务职责单一</li><li>解耦之后服务迭代速度加快，部署更加灵活</li><li>扩展性更强</li><li>灵活组合</li><li>技术异构</li></ul><h4 id="弊端"><a href="#弊端" class="headerlink" title="弊端:"></a>弊端:</h4><ul><li><p>服务的治理，运维带来很多麻烦</p></li><li><p>服务的复杂度增大</p></li><li><p>过细的拆分会影响整个系统的性格，例如以前只需要一次请求即可拿到数据，现在内部可能还依赖另外一个服务模块还需要请求另外一个服务拿结果</p></li></ul><h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><p>gRPC是一个高性能，开源通用，Google主导研发的RPC框架，基于HTTP2设计，使用ProtoBuf作为序列化协议，为移动端（Androi/IOS）到服务端通信提供一种解决方案。支持如下语言</p><ul><li><a href="src/cpp">C++</a>: follow the instructions under the <code>src/cpp</code> directory<ul><li><a href="src/csharp">C#</a>: NuGet package <code>Grpc</code></li><li><a href="https://github.com/grpc/grpc-dart" target="_blank" rel="noopener">Dart</a>: pub package <code>grpc</code></li><li><a href="https://github.com/grpc/grpc-go" target="_blank" rel="noopener">Go</a>: <code>go get google.golang.org/grpc</code></li><li><a href="https://github.com/grpc/grpc-java" target="_blank" rel="noopener">Java</a>: Use JARs from Maven Central Repository</li><li><a href="https://github.com/grpc/grpc-node" target="_blank" rel="noopener">Node</a>: <code>npm install grpc</code></li><li><a href="src/objective-c">Objective-C</a>: Add <code>gRPC-ProtoRPC</code> dependency to podspec</li><li><a href="src/php">PHP</a>: <code>pecl install grpc</code></li><li><a href="src/python/grpcio">Python</a>: <code>pip install grpcio</code></li><li><a href="src/ruby">Ruby</a>: <code>gem install grpc</code></li><li><a href="https://github.com/grpc/grpc-web" target="_blank" rel="noopener">WebJS</a>: follow the grpc-web instructions</li></ul></li></ul><h3 id="开发环境-win"><a href="#开发环境-win" class="headerlink" title="开发环境(win)"></a>开发环境(win)</h3><ul><li>python</li></ul><p>需要安装<code>grpcio-tools</code> 模块，可以使用pip直接安装即可</p><p>编译pb:<code>python -m grpc_tools.protoc --python_out=${compiler_output} --grpc_python_out=${compiler_output} --proto_path=${proto_dir} ${proto_file_path1}</code>${proto_file_path2}</p><p>python_out： 编译protobuf协议文件为python的输出路径</p><p>grpc_python_out: 指定输出编译代码代码目录</p><p>proto_path: proto文件的目录</p><p>最后面指定proto文件，这里可以指定多个</p><p>例如:</p><p>proto在如下目录<code>/test/rpc_server/proto/test.proto</code></p><p>在test级目录下，进入到CMD，运行如下命令:</p><p><code>python -m grpc_tools.protoc --python_out=&quot;./rpc_server&quot;  --grpc_python_out=&quot;./rpc_server&quot;  --proto_path=&quot;./proto&quot;  &quot;./proto/test.proto&quot;</code></p><ul><li><p>Go</p><p>在Windows下编译ProtoBuf需要依赖下面这个工具<code>protoc.exe</code> <code>protoc-gen-go.exe</code>，</p><p>安装grpc <code>go get google.golang.org/grpc</code></p><p>下载protoc</p><p>protoc.exe 可以在这里下载 <a href="https://github.com/protocolbuffers/protobuf/releases" target="_blank" rel="noopener">https://github.com/protocolbuffers/protobuf/releases</a></p><p>安装ProtoBuf插件protoc-gen-go </p><p><code>go install github.com/golang/protobuf/protoc-gen-go</code></p><p> 安装好了以后会在GoPath Bin目录下发现protoc-gen-go.exe</p></li></ul><p>  编译proto命令案例如下: `protoc –go_out=plugins=grpc:./ -I ${proto_dir}  ${proto_file_path}</p><p>  proto_dir： proto所在目录</p><p>  proto_file_path: proto文件路径</p><ul><li>00</li></ul><h3 id="ProtoBuf"><a href="#ProtoBuf" class="headerlink" title="ProtoBuf"></a>ProtoBuf</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>​     Protobuf是Google开源的一款类似于Json，XML数据交换格式，其内部数据是纯二进制格式，不依赖于语言和平台，具有简单，数据量小，快速等优点.protobuf是一套接口描述语言(Interface Definition Language ， IDL)，使用的时候要注意版本目前有两个版本proto2和proto3，语法和功能上有所区别。</p><h4 id="proto-数据类型"><a href="#proto-数据类型" class="headerlink" title="proto 数据类型"></a>proto 数据类型</h4><table><thead><tr><th>Proto</th><th>Java</th><th>C++</th><th>备注</th></tr></thead><tbody><tr><td>double</td><td>double</td><td>double</td><td></td></tr><tr><td>float</td><td>float</td><td>float</td><td></td></tr><tr><td>int32</td><td>int</td><td>int32</td><td>使用可变长编码方式。编码负数时不够高效——如果你的字段可能含有负数，那么请使用sint32。</td></tr><tr><td>int64</td><td>long</td><td>int64</td><td>使用可变长编码方式。编码负数时不够高效——如果你的字段可能含有负数，那么请使用sint64。</td></tr><tr><td>unit32</td><td>int[1]</td><td>unit32</td><td>总是4个字节。如果数值总是比总是比228大的话，这个类型会比uint32高效。</td></tr><tr><td>unit64</td><td>long[1]</td><td>unit64</td><td>总是8个字节。如果数值总是比总是比256大的话，这个类型会比uint64高效。</td></tr><tr><td>sint32</td><td>int</td><td>int32</td><td>使用可变长编码方式。有符号的整型值。编码时比通常的int32高效。</td></tr><tr><td>sint64</td><td>long</td><td>int64</td><td>使用可变长编码方式。有符号的整型值。编码时比通常的int64高效。</td></tr><tr><td>fixed32</td><td>int[1]</td><td>unit32</td><td></td></tr><tr><td>fixed64</td><td>long[1]</td><td>unit64</td><td>总是8个字节。如果数值总是比总是比256大的话，这个类型会比uint64高效。</td></tr><tr><td>sfixed32</td><td>int</td><td>int32</td><td>总是4个字节。</td></tr><tr><td>sfixed64</td><td>long</td><td>int64</td><td>总是8个字节。</td></tr><tr><td>bool</td><td>boolean</td><td>bool</td><td></td></tr><tr><td>string</td><td>String</td><td>string</td><td>一个字符串必须是UTF-8编码或者7-bit ASCII编码的文本。</td></tr><tr><td>bytes</td><td>ByteString</td><td>string</td><td>可能包含任意顺序的字节数据</td></tr></tbody></table><p>默认值</p><p>解析消息时，如果编码的消息不包含特定的单数元素，则已解析对象中的相应字段将设置为该字段的默认值。这些默认值是特定于类型的：</p><ul><li>对于字符串，默认值为空字符串。</li><li>对于字节，默认值为空字节。</li><li>对于布尔值，默认值为false。</li><li>对于数字类型，默认值为零。</li><li>对于<a href="https://developers.google.com/protocol-buffers/docs/proto3#enum" target="_blank" rel="noopener">枚举</a>，默认值为第<strong>一个定义的枚举值</strong>，必须为0。</li><li>对于消息字段，未设置该字段。它的确切值取决于语言。有关详细信息，请参见<a href="https://developers.google.com/protocol-buffers/docs/reference/overview" target="_blank" rel="noopener">生成的代码指南</a>。</li></ul><p>重复字段的默认值为空（通常为相应语言的空列表）。</p><p>对于标量消息字段，一旦解析了一条消息，就无法告诉该字段是显式设置为默认值（例如，是否将boolean设置为<code>false</code>）还是根本没有设置：您应该牢记这一点定义消息类型时。例如，<code>false</code>如果您不希望默认情况下也发生这种行为，则在设置为时，没有布尔值会打开某些行为。还要注意的是，如果一个标消息字段<strong>被</strong>设置为默认值，该值将不会在电线上连载。</p><p>有关默认值在生成的代码中如何工作的更多详细信息，请参见所选语言的<a href="https://developers.google.com/protocol-buffers/docs/reference/overview" target="_blank" rel="noopener">生成的代码指南</a>。</p><ul><li><p>Map类型</p><p>可以理解和Java中map类似即可，使用上基本一致</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">data</span> </span>&#123;</span><br><span class="line">  map&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;  Info = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> age = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Json map（proto3支持）</p><p><img src="https://img.halfrost.com/Blog/ArticleImage/84_4.png" alt=""></p></li></ul><h4 id="特殊字段"><a href="#特殊字段" class="headerlink" title="特殊字段"></a>特殊字段</h4><table><thead><tr><th>英文</th><th>中文</th><th>备注</th></tr></thead><tbody><tr><td>enum</td><td>枚举(数字从零开始) 作用是为字段指定某”预定义值序列”</td><td>enum Type {MAN = 0;WOMAN = 1; OTHER= 3;}</td></tr><tr><td>message</td><td>消息体</td><td>message User{}</td></tr><tr><td>repeated</td><td>数组/集合</td><td>repeated User users = 1</td></tr><tr><td>import</td><td>导入定义</td><td>import “protos/other_protos.proto”</td></tr><tr><td>//</td><td>注释</td><td>//用于注释</td></tr><tr><td>extend</td><td>扩展</td><td>extend User {}</td></tr><tr><td>package</td><td>包名</td><td>相当于命名空间，用来防止不同消息类型的明明冲突</td></tr></tbody></table><h4 id="Google插件"><a href="#Google插件" class="headerlink" title="Google插件"></a>Google插件</h4><ul><li>Any类型【google/protobuf/any.proto】(<a href="https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/any.proto" target="_blank" rel="noopener">Any类型proto</a>)</li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"google/protobuf/any.proto"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">ErrorStatus</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> <span class="class"><span class="keyword">message</span> = 1;</span></span><br><span class="line"><span class="class">  <span class="title">repeated</span> google.protobuf.Any details = 2;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>在Go语言中proto 的Any 类型对于Golang中是<code>[]*any.Any</code>,any来自于包<code>github.com/golang/protobuf/ptypes/any</code></p><ul><li><p>wrappers类型【google/protobuf/wrappers.proto】(<a href="https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wrappers.proto" target="_blank" rel="noopener">wrappers类型protot</a>)</p><p>对于gRPC中的缺失值和默认值问题，如果不引用wrappers类型，使用原来自带的数据类型，在传输的时候，如果传输的数据和类型的默认值一致的时候，gRPC默认是不会序列化，是不会传输的，从而节省空间，例如如下</p><p>假设A类型的默认值是A1这时候会出现如下情况</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">赋值A类型的数据为A1----------------不传输---------------------取值时取默认值</span><br><span class="line"></span><br><span class="line">没有赋值或者错误操作没有赋值---------不传输---------------------取值时取默认值</span><br></pre></td></tr></table></figure><p>对于上面情况很难区分是值得缺失还是默认值问题，这里可以引用wrappers proto插件，这时候不管是不是默认值都会传递给使用端，使用情况如下</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">google.protobuf.StringValuesyntax = <span class="string">"proto3"</span>;</span><br><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"google/protobuf/wrappers.proto"</span>;<span class="keyword">package</span> analyser;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">ErrorStatus</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> <span class="class"><span class="keyword">message</span> = 1;</span></span><br><span class="line"><span class="class">  <span class="title">google</span>.protobuf.StringValue = 2;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>  这里也可以使用oneof ,但是不推荐，推荐使用wrappers，感兴趣可以去看下oneof</p><p>  这里有相关的问答: <a href="https://stackoverflow.com/questions/42622015/how-to-define-an-optional-field-in-protobuf-3" target="_blank" rel="noopener">https://stackoverflow.com/questions/42622015/how-to-define-an-optional-field-in-protobuf-3</a></p><h4 id="proto2-3-区别"><a href="#proto2-3-区别" class="headerlink" title="proto2 -3 区别"></a>proto2 -3 区别</h4><ul><li>proto3 去掉了 <code>required</code> proto2 是可以通过<code>required</code> 标记是必要字段</li><li>proto3 第一行需要指定proto版本： <code>syntax = &quot;proto3&quot;;</code> 否则会被编译器认定为proto2，</li><li>proto3移除groups,proto2也废弃groups，可以用嵌套message代替</li><li>proto3移除extensions，增加Any，Any代替extensions</li><li>proto3增加json映射支持</li></ul><h4 id="proto-编码规范"><a href="#proto-编码规范" class="headerlink" title="proto 编码规范"></a>proto 编码规范</h4><ul><li><p>proto文件名命名规范</p><p>采用小写加下划线命名的方式例如:<code>lower_snake_case.proto</code></p></li><li><p>proto编码顺序</p></li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. License header (if applicable)</span><br><span class="line">2. File overview</span><br><span class="line">3. Syntax</span><br><span class="line">4. Package</span><br><span class="line">5. Imports (sorted)</span><br><span class="line">6. File options</span><br><span class="line">7. Everything else</span><br></pre></td></tr></table></figure><ul><li>proto package命名规范，使用小写，并且应该与目录层次结构相对应。例如，如果文件在my/package/中，那么包名应该是my.package。</li><li>Message 和 field 命名规范，message 采用驼峰命名规则，，对于字段field采用小写加下划线的命名规则例如</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message SongServerRequest &#123;</span><br><span class="line">  required string song_name &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于Repeated 修饰的字段应该采用英语复数形式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repeated string keys &#x3D; 1;</span><br><span class="line">  ...</span><br><span class="line">  repeated MyMessage accounts &#x3D; 17;</span><br></pre></td></tr></table></figure><ul><li>枚举类型，字段命名应该使用大写加下划线常量方式来命名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum Foo &#123;</span><br><span class="line">  FOO_UNSPECIFIED &#x3D; 0;</span><br><span class="line">  FOO_FIRST_VALUE &#x3D; 1;</span><br><span class="line">  FOO_SECOND_VALUE &#x3D; 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Services 服务名，采用驼峰命名规则</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service FooService &#123;</span><br><span class="line">  rpc GetSomething(FooRequest) returns (FooResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="noopener">protobuf官方语法介绍</a></p><p><a href="https://halfrost.com/protobuf_encode/" target="_blank" rel="noopener">protobuf</a></p><p><a href="https://yeasy.gitbooks.io/blockchain_guide/appendix/grpc.html" target="_blank" rel="noopener">ProtoBuf 与 gRPC</a>  </p><p><a href="https://developers.google.com/protocol-buffers/docs/proto3#any" target="_blank" rel="noopener">Any类型文档</a></p><p><a href="https://github.com/protocolbuffers/protobuf/tree/master/src/google/protobuf" target="_blank" rel="noopener">Google Protobuf 插件</a></p><p><a href="https://developers.google.com/protocol-buffers/docs/proto3#json" target="_blank" rel="noopener">proto3对Json的支持</a></p><p><a href="https://developers.google.com/protocol-buffers/docs/style" target="_blank" rel="noopener">proto编码规范</a></p>]]></content>
    
    <summary type="html">
    
      初步了解RPC/gPRC
    
    </summary>
    
    
      <category term="RPC" scheme="https://vollic.github.io/categories/RPC/"/>
    
    
      <category term="gRPC" scheme="https://vollic.github.io/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>能力提升Plan</title>
    <link href="https://vollic.github.io/category/plan/2020%E4%B8%AA%E4%BA%BA%E8%83%BD%E5%8A%9B%E6%8F%90%E5%8D%87Plan/"/>
    <id>https://vollic.github.io/category/plan/2020%E4%B8%AA%E4%BA%BA%E8%83%BD%E5%8A%9B%E6%8F%90%E5%8D%87Plan/</id>
    <published>2020-02-20T02:09:35.000Z</published>
    <updated>2020-02-22T01:44:06.047Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><pre class="mermaid">graph LRA[个人能力提升计划]   A-->A1(语言)    A1-->A11(Python)    A1-->A12(Golang)    A1-->A13(Scala)    A1-->A14(Shell)    A1-->A15(Java)  A-->A2(基本功)    A2-->A21(常用算法)    A2-->A22(数据结构)    A2-->A23(设计模式)  A-->A3(网络)    A3-->A31(IP)    A3-->A32(TCP)    A3-->A33(UDP)    A3-->A34(Socket)    A3-->A35(HTTP/HTTPS)  A-->A4(分布式系统)    A4-->A41(设计/开发)      A4-->A42(负载均衡)      A4-->A43(服务熔断)      A4-->A44(服务高可用)      A4-->A45(服务容灾)      A4-->A46(服务限流/降级)      A4-->A47(多线程开发/同步异步处理)    A-->A5(容器技术)    A5-->A51(Docker)    A5-->A52(Kubernetes)  A-->A6(大数据生态及组件)    A6-->A61(Hadoop)    A6-->A62(HDFS)    A6-->A63(HBase)    A6-->A64(Hive)    A6-->A65(Spark)    A6-->A66(Flink)    A6-->A67(TensorFlow)    A6-->A68(Kafka)    A6-->A69(Zookeeper)    A6-->A610(Mongodb)    A6-->A611(Redis)  A-->A7(潜在能力)    A7-->A71(学习能力)    A7-->A72(动手能力)    A7-->A73(英语能力)    A7-->A74(排查问题能力)      A74-->A741(GDB)      A74-->A742(DLV)      A74-->A743(pprof:golang)      A74-->A744(trace)      A74-->A745(独立分析coredump能力)</pre>]]></content>
    
    <summary type="html">
    
      2020 plan
    
    </summary>
    
    
      <category term="plan" scheme="https://vollic.github.io/categories/plan/"/>
    
    
      <category term="2020plan" scheme="https://vollic.github.io/tags/2020plan/"/>
    
  </entry>
  
  <entry>
    <title>Golang 异常处理</title>
    <link href="https://vollic.github.io/category/Go/exception/Golang%20Exception/"/>
    <id>https://vollic.github.io/category/Go/exception/Golang%20Exception/</id>
    <published>2020-02-20T02:09:35.000Z</published>
    <updated>2020-02-20T04:50:34.601Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="return-defer"><a href="#return-defer" class="headerlink" title="return/defer"></a>return/defer</h2><ul><li>return: 起到一个函数或者方法的返回值使用的关键字，或者直接使用<code>return</code>不带返回值并且返回声明没有命名返回值时起到一个中断的效果，注意它不具备原子操作，返回的过程中有个过程，赋值，再返回的操作</li><li>defer执行的顺序是压栈的形式，先进后出</li><li>defer和return的执行顺序是：先return再defer, return最先执行，return负责将结果写入返回值中；接着defer开始执行一些收尾工作；最后函数携带当前返回值退出。</li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="defer-return执行顺序案例"><a href="#defer-return执行顺序案例" class="headerlink" title="defer/return执行顺序案例:"></a>defer/return执行顺序案例:</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">k := <span class="number">100</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">k++</span><br><span class="line">fmt.Printf(<span class="string">"Now K:%d\n"</span>, k)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> k</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">res := test()</span><br><span class="line">fmt.Println(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//它的执行结果是100</span></span><br><span class="line">Now K:<span class="number">101</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><h4 id="多个defer执行顺序-注意区别"><a href="#多个defer执行顺序-注意区别" class="headerlink" title="多个defer执行顺序:(注意区别)"></a>多个defer执行顺序:(注意区别)</h4><ul><li>返回值没有命名的时候</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">k := <span class="number">100</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">k++</span><br><span class="line">fmt.Printf(<span class="string">"defer1:%d\n"</span>, k)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">k++</span><br><span class="line">fmt.Printf(<span class="string">"defer2:%d\n"</span>, k)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> k</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">res := test()</span><br><span class="line">fmt.Println(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果为:</span></span><br><span class="line">defer2:<span class="number">101</span></span><br><span class="line">defer1:<span class="number">102</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><ul><li><p>返回值被命名的时候</p><p>当返回值被命名的时候，会默认返回k，也可以显性表示return k ，存在多个返回值时，多个返回值需要同时命名或同时未命名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="params">(k <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      k++</span><br><span class="line">      fmt.Printf(<span class="string">"defer1:%d\n"</span>, k)</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      k++</span><br><span class="line">      fmt.Printf(<span class="string">"defer2:%d\n"</span>, k)</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   res := test()</span><br><span class="line">   fmt.Println(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果:</span></span><br><span class="line">defer2:<span class="number">1</span></span><br><span class="line">defer1:<span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="params">(k <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">k++</span><br><span class="line">fmt.Printf(<span class="string">"defer1:%d\n"</span>, k)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">k++</span><br><span class="line">fmt.Printf(<span class="string">"defer2:%d\n"</span>, k)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">300</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">res := test()</span><br><span class="line">fmt.Println(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果:</span></span><br><span class="line">defer2:<span class="number">301</span></span><br><span class="line">defer1:<span class="number">302</span></span><br><span class="line"><span class="number">302</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="panic-recover"><a href="#panic-recover" class="headerlink" title="panic/recover"></a>panic/recover</h2><ul><li>一个函数只能panic一次</li><li>遇到panic的时候，函数不再往下执行了，而是直接跳到defer代码块(defer定义在panic之前)，再往上层panic，类似于try-catch-finally中的finally</li><li>panic会往上一层panic，但是当前函数有recover的话，会捕获到当前的panic，否则上层无法捕获，程序直接中断跳出</li></ul><p>使用如下:</p><p>不可以直接<code>defer recover()</code>，如果把下面的recover放入到main中，main发生panic的函数后面的代码就无法执行了，一定是当前函数发生panic，当前函数recover</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calu</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> k = rand.Int()</span><br><span class="line">   <span class="keyword">if</span> k &gt; <span class="number">0</span> &#123;</span><br><span class="line">      k = <span class="number">0</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="number">5</span> / k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">         fmt.Printf(<span class="string">"execute work func meet err! %v\n"</span>, e)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   calu()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   work()</span><br><span class="line">   fmt.Println(<span class="string">"finished...."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果如下</span></span><br><span class="line">execute work <span class="function"><span class="keyword">func</span> <span class="title">meet</span> <span class="title">err</span>! <span class="title">runtime</span> <span class="title">error</span>: <span class="title">integer</span> <span class="title">divide</span> <span class="title">by</span> <span class="title">zero</span></span></span><br><span class="line">finished....</span><br></pre></td></tr></table></figure><h3 id="defer-retrun，panic-recover执行顺序"><a href="#defer-retrun，panic-recover执行顺序" class="headerlink" title="defer/retrun，panic/recover执行顺序"></a>defer/retrun，panic/recover执行顺序</h3><p>看如下代码案例:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calu</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> k = rand.Int()</span><br><span class="line">   <span class="keyword">if</span> k &gt; <span class="number">0</span> &#123;</span><br><span class="line">      k = <span class="number">0</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="number">5</span> / k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">()</span> <span class="title">int</span></span>&#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">         fmt.Printf(<span class="string">"execute work func meet err! %v\n"</span>, e)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   calu()</span><br><span class="line">   fmt.Println(<span class="string">"calu finished"</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   r := work()</span><br><span class="line">   fmt.Println(r)</span><br><span class="line">   fmt.Println(<span class="string">"finished...."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">execute work <span class="function"><span class="keyword">func</span> <span class="title">meet</span> <span class="title">err</span>! <span class="title">runtime</span> <span class="title">error</span>: <span class="title">integer</span> <span class="title">divide</span> <span class="title">by</span> <span class="title">zero</span></span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">finished....</span><br></pre></td></tr></table></figure><p>执行轨迹:</p><p>发生<code>panic</code>的函数—-&gt;<code>defer</code>中的<code>recover</code>捕获到异常——&gt;<code>return</code>返回类型的默认值</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>始终理解一点，return只是返回标志，并不代表结束，return是一个过程</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="number">100</span></span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line"># <span class="keyword">return</span> 过程</span><br><span class="line"><span class="keyword">var</span> retTmp in</span><br><span class="line">retTmp = s</span><br><span class="line"><span class="keyword">return</span> retTmp</span><br></pre></td></tr></table></figure><p>始终要理解上面的中间变量retTmp，哪怕defer里面对s变量怎么修改，retTmp是不会改变的，但返回值显示申明的时候，这时候你可以理解为这个中间变量retTmp和声明的是同一个</p>]]></content>
    
    <summary type="html">
    
      Go 异常处理之defer、return、panic、recover
    
    </summary>
    
    
      <category term="Go" scheme="https://vollic.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://vollic.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Golang 中的 goroutine简单理解和使用</title>
    <link href="https://vollic.github.io/category/Go/goroutine/goroutine/"/>
    <id>https://vollic.github.io/category/Go/goroutine/goroutine/</id>
    <published>2020-02-16T02:22:56.000Z</published>
    <updated>2020-02-20T04:56:40.646Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><h2 id="什么是goroutine"><a href="#什么是goroutine" class="headerlink" title="什么是goroutine"></a>什么是goroutine</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li><p>进程</p><p>进程是系统进行资源分配的和调度的基本单元，具有独立功能的程序在某个数据集合上的一次执行过程</p></li><li><p>线程</p></li></ul><p>​       线程是进程的一个执行实体或者执行单元，是比进程更小的且能独立运行的基本单元，一个进程至少会有一个线程</p><ul><li><p>协程</p><p>协程又被称作为微协程，纤程。</p><p>协程相对独立有自己的上下文，由线程拉起，和线程相比协程避免了无意义的调度因此提高了性能，协程相对线程而言节约的是CPU的切换时间，但需要开发人员自己通过代码去调度kong</p></li><li><p>goroutine</p></li></ul><p>​    goroutine是Go语言的协程实现，从调度上讲goroutine的调度开销远远小于线程调度开销，不同的是Go在runtime和系统调用等方面对goroutine做了封装处理，goroutine不完全是受开发人员控制，一定程度上由Go runtime管理, 当某个goroutine受阻塞时，会让出CPU资源给其他的goroutine, Golang 的一大特色就是从语言层面原生支持协程，在函数或者方法前面加 go关键字就可创建一个协程。</p><h2 id="CSP并发模型"><a href="#CSP并发模型" class="headerlink" title="CSP并发模型"></a>CSP并发模型</h2><p>​          这里简单介绍下CSP，后面专门写一篇详细介绍CSP模型, CSP(communicating sequential processes)它不同与多线程通过共享内存来通信，像Java中共享内存通信时需要考虑线程安全问题,<code>原子性</code>、<code>有序性</code>、<code>可见性</code>。CSP模型讲究的是通过通信来共享内存，这也是Go语言特有的并发模型，CSP模型主要通过Go的goroutine和channel来实现。</p><h2 id="GPM模型"><a href="#GPM模型" class="headerlink" title="GPM模型"></a>GPM模型</h2><p>这里也是简单了解和介绍，后面将详细介绍</p><p>G: Goroutine ，本质上一种轻量级的线程</p><p>P: Processor, 代表了M所需要上下文环境，处理用户级代码逻辑的处理器，这里是一个抽象的概念并非真正的CPU，当P有任务时需要创建或者唤醒一个系统线程来执行它队列里面任务，所以需要P与M的绑定形成一个执行单元</p><p>M: Machine, 关联系统的一个内核线程，每次创建一个M时候都会有一个底层线程创建，所有的G任务最后都是在G上面运行</p><p>它们之间的关系如下：</p><p>​    一个M(Machine)对应一个系统内核线程，也会连接一个上下文P(Processor)，一个上下文P会关联多个G(Goroutine )</p><h2 id="goroutine实际应用"><a href="#goroutine实际应用" class="headerlink" title="goroutine实际应用"></a>goroutine实际应用</h2><p>​    Go的并发写起来非常容器不像其他语言，只需要一个go关键字就可以搞定，例如:<code>go work()</code>, 在启动一个goroutine，一定需要知道它时何时关闭的，并且要节约使用，考虑它的必要性避免滥用，使用goroutine会给程序带来风险特别是死锁，对于后面问题排除也会带来很大的麻烦</p><h3 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h3><p>​    当我们启动一个goroutine时候，我们必须考虑它何时结束，但运行时间较长的时候，不做任何操作，这时候如果main主进程运行结束，会导致进程直接退出，不会考虑启动的goroutine有没有结束，甚至可能goroutine还没有起来，main已经运行完了，有必要的时候需要等待启动的goroutine运行完再退出，有人可能马上想到用sleep的方式，sleep不能准确估计goroutine运行时间，甚至可能会导致进程一直卡住，这里我们需要一个管理者，这个管理者就是sync.WaitGroup</p><p>案例代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"sync"</span></span><br><span class="line">   <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">(data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   fmt.Println(data)</span><br><span class="line">   time.Sleep(time.Duration(<span class="number">1</span>) * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   gNum := <span class="number">5</span></span><br><span class="line">   <span class="keyword">var</span> wg = sync.WaitGroup&#123;&#125;</span><br><span class="line">   wg.Add(gNum)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= gNum; i++ &#123;</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(w sync.WaitGroup, data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">         work(data)</span><br><span class="line">         wg.Done()</span><br><span class="line">      &#125;(wg, i)</span><br><span class="line">   &#125;</span><br><span class="line">   wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>使用的时候一定要保证设置等待的goroutine，最后一定要Done关闭掉不然就会导致死锁</p><h3 id="使用channel传递信息"><a href="#使用channel传递信息" class="headerlink" title="使用channel传递信息"></a>使用channel传递信息</h3><p> channle一定得小心使用，一定不要滥用，channel使用不当很容器造成死锁，并且channel使用注意以下几点</p><ul><li>不能往关闭的channle发消息</li><li>不能只发消息或者不能只接受消息，只在单一的goroutine里操作无缓冲信道，一定会死锁，例如下面代码中的订阅者，如果不加超时机制，如果发布者关闭或者退出了订阅者等待的消息永远等不到就会造成死锁</li><li>两个通道依赖使用,一个通道的输出作为另外一个通道的输入，例如<code>c1&lt;-&lt;-c2</code>，这个很容易造成两个goroutine等待变成死锁</li></ul><p>简单的发布订阅通过channel实现如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的发布订阅，通过channel实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Publisher <span class="keyword">struct</span> &#123;</span><br><span class="line">PubMsg     <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line">StopSignal <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">publish</span><span class="params">(p Publisher, w *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">duration := time.Duration(<span class="number">1</span>) * time.Second</span><br><span class="line">tick := time.NewTicker(duration)</span><br><span class="line"><span class="keyword">var</span> msgCnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"publisher will exit......."</span>)</span><br><span class="line">tick.Stop()</span><br><span class="line">w.Done()</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-tick.C:</span><br><span class="line"><span class="comment">// 每秒发布一条消息</span></span><br><span class="line">p.PubMsg &lt;- fmt.Sprintf(<span class="string">"消息-%d"</span>, msgCnt)</span><br><span class="line">msgCnt++</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里模拟关闭发布者</span></span><br><span class="line"><span class="keyword">if</span> msgCnt &gt;= <span class="number">5</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> &lt;-p.StopSignal:</span><br><span class="line">fmt.Println(<span class="string">"收到停止发送信号,将关闭publish..."</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subscriber</span><span class="params">(p Publisher, w *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">d := time.Duration(<span class="number">2</span>) * time.Second</span><br><span class="line">timeout := time.NewTimer(d)</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"subscriber will exit......."</span>)</span><br><span class="line">timeout.Stop()</span><br><span class="line">w.Done()</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> msg := &lt;-p.PubMsg:</span><br><span class="line">fmt.Printf(<span class="string">"收到订阅消息:%s\n"</span>, msg)</span><br><span class="line">timeout.Reset(d)</span><br><span class="line"><span class="comment">// 设置收取消息超时防止死锁</span></span><br><span class="line"><span class="keyword">case</span> &lt;-timeout.C:</span><br><span class="line">fmt.Println(<span class="string">"收取消息超时!!!"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 消息通道</span></span><br><span class="line">msgChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="comment">// 停止信号通道</span></span><br><span class="line">singleChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">publisher := Publisher&#123;msgChan, singleChan&#125;</span><br><span class="line">wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> publish(publisher, wg)</span><br><span class="line"><span class="keyword">go</span> subscriber(publisher, wg)</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>goroutine本质是协程，也是Go实现并行的核心，用起来比较简单，但是用好它不太容易，使用时一定要设计好，考虑是否一定要用它。</p>]]></content>
    
    <summary type="html">
    
      简单理解和使用goroutine
    
    </summary>
    
    
      <category term="Go" scheme="https://vollic.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://vollic.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="https://vollic.github.io/category/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/proxy/"/>
    <id>https://vollic.github.io/category/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/proxy/</id>
    <published>2020-02-15T02:08:40.000Z</published>
    <updated>2020-02-20T04:57:27.142Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    代理模式为其他对象提供一种代理以控制对这个对象的访问权限，它主要解决直接访问对象带来的问题，例如公司环境访问通过堡垒机代理访问生产环境权限，避免了生成环境权限全部开发的局面，只需要开放相应的权限给开发者即可，注意它不需要更改原始接口的内容</p><p>​     例如下面堡垒机，在原始虚拟机VM上做权限控制和审计功能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"errors"</span></span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始虚拟机拥有读写和执行权限</span></span><br><span class="line"><span class="keyword">type</span> VM <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vm *VM)</span> <span class="title">Write</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"Permission to write...."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vm *VM)</span> <span class="title">Read</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"Permission to Read....."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vm *VM)</span> <span class="title">execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"Permission to execute....."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堡垒机</span></span><br><span class="line"><span class="keyword">type</span> AccessGateway <span class="keyword">struct</span> &#123;</span><br><span class="line">   v *VM</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堡垒机可以做相关权限控制,和审计功能</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAccessGateWay</span><span class="params">(username <span class="keyword">string</span>)</span> <span class="params">(*AccessGateway, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> username != <span class="string">"Yu"</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"Username not enough permissions"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">"[%s] login into access gate wasy......\n"</span>, username)</span><br><span class="line">   <span class="keyword">return</span> &amp;AccessGateway&#123;&amp;VM&#123;&#125;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ag *AccessGateway)</span> <span class="title">Read</span><span class="params">()</span></span> &#123;</span><br><span class="line">   ag.v.Read()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ag *AccessGateway)</span> <span class="title">Write</span><span class="params">()</span></span> &#123;</span><br><span class="line">   ag.v.Write()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> accessGateway, err = NewAccessGateWay(<span class="string">"Yu"</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"Login into access gateway meet err! %v"</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   accessGateway.Write()</span><br><span class="line">   accessGateway.Read()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Yu</span>] login into access gate wasy......</span><br><span class="line">Permission to write....</span><br><span class="line">Permission to Read.....</span><br><span class="line"></span><br><span class="line"><span class="keyword">Process</span> finished with <span class="keyword">exit</span> code <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      proxy模式使用和理解
    
    </summary>
    
    
      <category term="设计模式" scheme="https://vollic.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://vollic.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://vollic.github.io/category/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/singleton/"/>
    <id>https://vollic.github.io/category/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/singleton/</id>
    <published>2020-02-13T04:08:40.000Z</published>
    <updated>2020-02-18T03:29:16.963Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="./test.png" alt="test"></p><p>单例模式是我们平常开发中用的最多设计模式之一，单例有很多级别上的，例如函数上的单例，进程上的单例，下面讲的是代码中的单例，只要了解单例的思想即可，语言知识实现工具，下面讲解如下几种类型单例模式</p><ul><li>饿汉模式</li><li>懒汉模式</li><li>懒汉模式(加锁)</li><li>懒汉模式(双重检查加锁)</li><li>sync.Once实现</li></ul><p>相关代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SingleTon <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> singleTon *SingleTon</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="comment">//懒汉模式</span></span><br><span class="line"><span class="comment">//还有一种饿汉式，就是一开始就初始化singleTon,实现如下</span></span><br><span class="line"><span class="comment">//func init() &#123;</span></span><br><span class="line"><span class="comment">// singleTon = &amp;SingleTon&#123;&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSingleTon</span><span class="params">()</span> *<span class="title">SingleTon</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> singleTon == <span class="literal">nil</span> &#123;</span><br><span class="line">      singleTon = &amp;SingleTon&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> singleTon</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒汉加锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSingleTonByLock</span><span class="params">()</span> *<span class="title">SingleTon</span></span> &#123;</span><br><span class="line">   mu.Lock()</span><br><span class="line">   <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> singleTon == <span class="literal">nil</span> &#123;</span><br><span class="line">      singleTon = &amp;SingleTon&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> singleTon</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒汉加检查锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSingleTonByLock2</span><span class="params">()</span> *<span class="title">SingleTon</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> singleTon == <span class="literal">nil</span> &#123;</span><br><span class="line">      mu.Lock()</span><br><span class="line">      <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> singleTon == <span class="literal">nil</span> &#123;</span><br><span class="line">         singleTon = &amp;SingleTon&#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> singleTon</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过sync.Once实现</span></span><br><span class="line"><span class="comment">// 看过Once包的知道，实现很简单通过加锁实现，通过done标记位来判断，运行过一次通过原子操作将done置为1</span></span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSingleTonByOnce</span><span class="params">()</span> *<span class="title">SingleTon</span></span> &#123;</span><br><span class="line">   once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      singleTon = &amp;SingleTon&#123;&#125;</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> singleTon</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      单例模式通过Go来实现
    
    </summary>
    
    
      <category term="设计模式" scheme="https://vollic.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://vollic.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
