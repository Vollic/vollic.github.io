<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>能力提升Plan</title>
    <url>/category/plan/2020%E4%B8%AA%E4%BA%BA%E8%83%BD%E5%8A%9B%E6%8F%90%E5%8D%87Plan/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><pre class="mermaid">graph LR
A[个人能力提升计划] 
  A-->A1(语言)
    A1-->A11(Python)
    A1-->A12(Golang)
    A1-->A13(Scala)
    A1-->A14(Shell)
    A1-->A15(Java)
  A-->A2(基本功)
    A2-->A21(常用算法)
    A2-->A22(数据结构)
    A2-->A23(设计模式)
  A-->A3(网络)
    A3-->A31(IP)
    A3-->A32(TCP)
    A3-->A33(UDP)
    A3-->A34(Socket)
    A3-->A35(HTTP/HTTPS)
  A-->A4(分布式系统)
    A4-->A41(设计/开发)  
    A4-->A42(负载均衡)  
    A4-->A43(服务熔断)  
    A4-->A44(服务高可用)  
    A4-->A45(服务容灾)  
    A4-->A46(服务限流/降级)  
    A4-->A47(多线程开发/同步异步处理)  
  A-->A5(容器技术)
    A5-->A51(Docker)
    A5-->A52(Kubernetes)
  A-->A6(大数据生态及组件)
    A6-->A61(Hadoop)
    A6-->A62(HDFS)
    A6-->A63(HBase)
    A6-->A64(Hive)
    A6-->A65(Spark)
    A6-->A66(Flink)
    A6-->A67(TensorFlow)
    A6-->A68(Kafka)
    A6-->A69(Zookeeper)
    A6-->A610(Mongodb)
    A6-->A611(Redis)
  A-->A7(潜在能力)
    A7-->A71(学习能力)
    A7-->A72(动手能力)
    A7-->A73(英语能力)
    A7-->A74(排查问题能力)
      A74-->A741(GDB)
      A74-->A742(DLV)
      A74-->A743(pprof:golang)
      A74-->A744(trace)
      A74-->A745(独立分析coredump能力)</pre>







]]></content>
      <categories>
        <category>plan</category>
      </categories>
      <tags>
        <tag>2020plan</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 异常处理</title>
    <url>/category/Go/exception/Golang%20Exception/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="return-defer"><a href="#return-defer" class="headerlink" title="return/defer"></a>return/defer</h2><ul>
<li>return: 起到一个函数或者方法的返回值使用的关键字，或者直接使用<code>return</code>不带返回值并且返回声明没有命名返回值时起到一个中断的效果，注意它不具备原子操作，返回的过程中有个过程，赋值，再返回的操作</li>
<li>defer执行的顺序是压栈的形式，先进后出</li>
<li>defer和return的执行顺序是：先return再defer, return最先执行，return负责将结果写入返回值中；接着defer开始执行一些收尾工作；最后函数携带当前返回值退出。</li>
</ul>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="defer-return执行顺序案例"><a href="#defer-return执行顺序案例" class="headerlink" title="defer/return执行顺序案例:"></a>defer/return执行顺序案例:</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	k := <span class="number">100</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		k++</span><br><span class="line">		fmt.Printf(<span class="string">"Now K:%d\n"</span>, k)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> k</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	res := test()</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//它的执行结果是100</span></span><br><span class="line">Now K:<span class="number">101</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>



<h4 id="多个defer执行顺序-注意区别"><a href="#多个defer执行顺序-注意区别" class="headerlink" title="多个defer执行顺序:(注意区别)"></a>多个defer执行顺序:(注意区别)</h4><ul>
<li>返回值没有命名的时候</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	k := <span class="number">100</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		k++</span><br><span class="line">		fmt.Printf(<span class="string">"defer1:%d\n"</span>, k)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		k++</span><br><span class="line">		fmt.Printf(<span class="string">"defer2:%d\n"</span>, k)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> k</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	res := test()</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果为:</span></span><br><span class="line">defer2:<span class="number">101</span></span><br><span class="line">defer1:<span class="number">102</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>返回值被命名的时候</p>
<p>当返回值被命名的时候，会默认返回k，也可以显性表示return k ，存在多个返回值时，多个返回值需要同时命名或同时未命名</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="params">(k <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      k++</span><br><span class="line">      fmt.Printf(<span class="string">"defer1:%d\n"</span>, k)</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      k++</span><br><span class="line">      fmt.Printf(<span class="string">"defer2:%d\n"</span>, k)</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   res := test()</span><br><span class="line">   fmt.Println(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果:</span></span><br><span class="line">defer2:<span class="number">1</span></span><br><span class="line">defer1:<span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="params">(k <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		k++</span><br><span class="line">		fmt.Printf(<span class="string">"defer1:%d\n"</span>, k)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		k++</span><br><span class="line">		fmt.Printf(<span class="string">"defer2:%d\n"</span>, k)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">300</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	res := test()</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果:</span></span><br><span class="line">defer2:<span class="number">301</span></span><br><span class="line">defer1:<span class="number">302</span></span><br><span class="line"><span class="number">302</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="panic-recover"><a href="#panic-recover" class="headerlink" title="panic/recover"></a>panic/recover</h2><ul>
<li>一个函数只能panic一次</li>
<li>遇到panic的时候，函数不再往下执行了，而是直接跳到defer代码块(defer定义在panic之前)，再往上层panic，类似于try-catch-finally中的finally</li>
<li>panic会往上一层panic，但是当前函数有recover的话，会捕获到当前的panic，否则上层无法捕获，程序直接中断跳出</li>
</ul>
<p>使用如下:</p>
<p>不可以直接<code>defer recover()</code>，如果把下面的recover放入到main中，main发生panic的函数后面的代码就无法执行了，一定是当前函数发生panic，当前函数recover</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calu</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> k = rand.Int()</span><br><span class="line">   <span class="keyword">if</span> k &gt; <span class="number">0</span> &#123;</span><br><span class="line">      k = <span class="number">0</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="number">5</span> / k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">         fmt.Printf(<span class="string">"execute work func meet err! %v\n"</span>, e)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   calu()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   work()</span><br><span class="line">   fmt.Println(<span class="string">"finished...."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果如下</span></span><br><span class="line">execute work <span class="function"><span class="keyword">func</span> <span class="title">meet</span> <span class="title">err</span>! <span class="title">runtime</span> <span class="title">error</span>: <span class="title">integer</span> <span class="title">divide</span> <span class="title">by</span> <span class="title">zero</span></span></span><br><span class="line">finished....</span><br></pre></td></tr></table></figure>



<h3 id="defer-retrun，panic-recover执行顺序"><a href="#defer-retrun，panic-recover执行顺序" class="headerlink" title="defer/retrun，panic/recover执行顺序"></a>defer/retrun，panic/recover执行顺序</h3><p>看如下代码案例:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calu</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> k = rand.Int()</span><br><span class="line">   <span class="keyword">if</span> k &gt; <span class="number">0</span> &#123;</span><br><span class="line">      k = <span class="number">0</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="number">5</span> / k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">()</span> <span class="title">int</span></span>&#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">         fmt.Printf(<span class="string">"execute work func meet err! %v\n"</span>, e)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   calu()</span><br><span class="line">   fmt.Println(<span class="string">"calu finished"</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   r := work()</span><br><span class="line">   fmt.Println(r)</span><br><span class="line">   fmt.Println(<span class="string">"finished...."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">execute work <span class="function"><span class="keyword">func</span> <span class="title">meet</span> <span class="title">err</span>! <span class="title">runtime</span> <span class="title">error</span>: <span class="title">integer</span> <span class="title">divide</span> <span class="title">by</span> <span class="title">zero</span></span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">finished....</span><br></pre></td></tr></table></figure>



<p>执行轨迹:</p>
<p>发生<code>panic</code>的函数—-&gt;<code>defer</code>中的<code>recover</code>捕获到异常——&gt;<code>return</code>返回类型的默认值</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>始终理解一点，return只是返回标志，并不代表结束，return是一个过程</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="number">100</span></span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line"># <span class="keyword">return</span> 过程</span><br><span class="line"><span class="keyword">var</span> retTmp in</span><br><span class="line">retTmp = s</span><br><span class="line"><span class="keyword">return</span> retTmp</span><br></pre></td></tr></table></figure>

<p>始终要理解上面的中间变量retTmp，哪怕defer里面对s变量怎么修改，retTmp是不会改变的，但返回值显示申明的时候，这时候你可以理解为这个中间变量retTmp和声明的是同一个</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 中的 goroutine简单理解和使用</title>
    <url>/category/Go/goroutine/goroutine/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc -->

<h2 id="什么是goroutine"><a href="#什么是goroutine" class="headerlink" title="什么是goroutine"></a>什么是goroutine</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul>
<li><p>进程</p>
<p>进程是系统进行资源分配的和调度的基本单元，具有独立功能的程序在某个数据集合上的一次执行过程</p>
</li>
<li><p>线程</p>
</li>
</ul>
<p>​       线程是进程的一个执行实体或者执行单元，是比进程更小的且能独立运行的基本单元，一个进程至少会有一个线程</p>
<ul>
<li><p>协程</p>
<p>协程又被称作为微协程，纤程。</p>
<p>协程相对独立有自己的上下文，由线程拉起，和线程相比协程避免了无意义的调度因此提高了性能，协程相对线程而言节约的是CPU的切换时间，但需要开发人员自己通过代码去调度kong</p>
</li>
<li><p>goroutine</p>
</li>
</ul>
<p>​    goroutine是Go语言的协程实现，从调度上讲goroutine的调度开销远远小于线程调度开销，不同的是Go在runtime和系统调用等方面对goroutine做了封装处理，goroutine不完全是受开发人员控制，一定程度上由Go runtime管理, 当某个goroutine受阻塞时，会让出CPU资源给其他的goroutine, Golang 的一大特色就是从语言层面原生支持协程，在函数或者方法前面加 go关键字就可创建一个协程。</p>
<h2 id="CSP并发模型"><a href="#CSP并发模型" class="headerlink" title="CSP并发模型"></a>CSP并发模型</h2><p>​          这里简单介绍下CSP，后面专门写一篇详细介绍CSP模型, CSP(communicating sequential processes)它不同与多线程通过共享内存来通信，像Java中共享内存通信时需要考虑线程安全问题,<code>原子性</code>、<code>有序性</code>、<code>可见性</code>。CSP模型讲究的是通过通信来共享内存，这也是Go语言特有的并发模型，CSP模型主要通过Go的goroutine和channel来实现。</p>
<h2 id="GPM模型"><a href="#GPM模型" class="headerlink" title="GPM模型"></a>GPM模型</h2><p>这里也是简单了解和介绍，后面将详细介绍</p>
<p>G: Goroutine ，本质上一种轻量级的线程</p>
<p>P: Processor, 代表了M所需要上下文环境，处理用户级代码逻辑的处理器，这里是一个抽象的概念并非真正的CPU，当P有任务时需要创建或者唤醒一个系统线程来执行它队列里面任务，所以需要P与M的绑定形成一个执行单元</p>
<p>M: Machine, 关联系统的一个内核线程，每次创建一个M时候都会有一个底层线程创建，所有的G任务最后都是在G上面运行</p>
<p>它们之间的关系如下：</p>
<p>​    一个M(Machine)对应一个系统内核线程，也会连接一个上下文P(Processor)，一个上下文P会关联多个G(Goroutine )</p>
<h2 id="goroutine实际应用"><a href="#goroutine实际应用" class="headerlink" title="goroutine实际应用"></a>goroutine实际应用</h2><p>​    Go的并发写起来非常容器不像其他语言，只需要一个go关键字就可以搞定，例如:<code>go work()</code>, 在启动一个goroutine，一定需要知道它时何时关闭的，并且要节约使用，考虑它的必要性避免滥用，使用goroutine会给程序带来风险特别是死锁，对于后面问题排除也会带来很大的麻烦</p>
<h3 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h3><p>​    当我们启动一个goroutine时候，我们必须考虑它何时结束，但运行时间较长的时候，不做任何操作，这时候如果main主进程运行结束，会导致进程直接退出，不会考虑启动的goroutine有没有结束，甚至可能goroutine还没有起来，main已经运行完了，有必要的时候需要等待启动的goroutine运行完再退出，有人可能马上想到用sleep的方式，sleep不能准确估计goroutine运行时间，甚至可能会导致进程一直卡住，这里我们需要一个管理者，这个管理者就是sync.WaitGroup</p>
<p>案例代码如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"sync"</span></span><br><span class="line">   <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">(data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   fmt.Println(data)</span><br><span class="line">   time.Sleep(time.Duration(<span class="number">1</span>) * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   gNum := <span class="number">5</span></span><br><span class="line">   <span class="keyword">var</span> wg = sync.WaitGroup&#123;&#125;</span><br><span class="line">   wg.Add(gNum)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= gNum; i++ &#123;</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(w sync.WaitGroup, data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">         work(data)</span><br><span class="line">         wg.Done()</span><br><span class="line">      &#125;(wg, i)</span><br><span class="line">   &#125;</span><br><span class="line">   wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>



<p>使用的时候一定要保证设置等待的goroutine，最后一定要Done关闭掉不然就会导致死锁</p>
<h3 id="使用channel传递信息"><a href="#使用channel传递信息" class="headerlink" title="使用channel传递信息"></a>使用channel传递信息</h3><p> channle一定得小心使用，一定不要滥用，channel使用不当很容器造成死锁，并且channel使用注意以下几点</p>
<ul>
<li>不能往关闭的channle发消息</li>
<li>不能只发消息或者不能只接受消息，只在单一的goroutine里操作无缓冲信道，一定会死锁，例如下面代码中的订阅者，如果不加超时机制，如果发布者关闭或者退出了订阅者等待的消息永远等不到就会造成死锁</li>
<li>两个通道依赖使用,一个通道的输出作为另外一个通道的输入，例如<code>c1&lt;-&lt;-c2</code>，这个很容易造成两个goroutine等待变成死锁</li>
</ul>
<p>简单的发布订阅通过channel实现如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的发布订阅，通过channel实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Publisher <span class="keyword">struct</span> &#123;</span><br><span class="line">	PubMsg     <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line">	StopSignal <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">publish</span><span class="params">(p Publisher, w *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	duration := time.Duration(<span class="number">1</span>) * time.Second</span><br><span class="line">	tick := time.NewTicker(duration)</span><br><span class="line">	<span class="keyword">var</span> msgCnt = <span class="number">0</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"publisher will exit......."</span>)</span><br><span class="line">		tick.Stop()</span><br><span class="line">		w.Done()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-tick.C:</span><br><span class="line">			<span class="comment">// 每秒发布一条消息</span></span><br><span class="line">			p.PubMsg &lt;- fmt.Sprintf(<span class="string">"消息-%d"</span>, msgCnt)</span><br><span class="line">			msgCnt++</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 这里模拟关闭发布者</span></span><br><span class="line">			<span class="keyword">if</span> msgCnt &gt;= <span class="number">5</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-p.StopSignal:</span><br><span class="line">			fmt.Println(<span class="string">"收到停止发送信号,将关闭publish..."</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subscriber</span><span class="params">(p Publisher, w *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	d := time.Duration(<span class="number">2</span>) * time.Second</span><br><span class="line">	timeout := time.NewTimer(d)</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"subscriber will exit......."</span>)</span><br><span class="line">		timeout.Stop()</span><br><span class="line">		w.Done()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> msg := &lt;-p.PubMsg:</span><br><span class="line">			fmt.Printf(<span class="string">"收到订阅消息:%s\n"</span>, msg)</span><br><span class="line">			timeout.Reset(d)</span><br><span class="line">		<span class="comment">// 设置收取消息超时防止死锁</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-timeout.C:</span><br><span class="line">			fmt.Println(<span class="string">"收取消息超时!!!"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 消息通道</span></span><br><span class="line">	msgChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	<span class="comment">// 停止信号通道</span></span><br><span class="line">	singleChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	publisher := Publisher&#123;msgChan, singleChan&#125;</span><br><span class="line">	wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> publish(publisher, wg)</span><br><span class="line">	<span class="keyword">go</span> subscriber(publisher, wg)</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>goroutine本质是协程，也是Go实现并行的核心，用起来比较简单，但是用好它不太容易，使用时一定要设计好，考虑是否一定要用它。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/category/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/proxy/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    代理模式为其他对象提供一种代理以控制对这个对象的访问权限，它主要解决直接访问对象带来的问题，例如公司环境访问通过堡垒机代理访问生产环境权限，避免了生成环境权限全部开发的局面，只需要开放相应的权限给开发者即可，注意它不需要更改原始接口的内容</p>
<p>​     例如下面堡垒机，在原始虚拟机VM上做权限控制和审计功能</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"errors"</span></span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始虚拟机拥有读写和执行权限</span></span><br><span class="line"><span class="keyword">type</span> VM <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vm *VM)</span> <span class="title">Write</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"Permission to write...."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vm *VM)</span> <span class="title">Read</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"Permission to Read....."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vm *VM)</span> <span class="title">execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"Permission to execute....."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堡垒机</span></span><br><span class="line"><span class="keyword">type</span> AccessGateway <span class="keyword">struct</span> &#123;</span><br><span class="line">   v *VM</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堡垒机可以做相关权限控制,和审计功能</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAccessGateWay</span><span class="params">(username <span class="keyword">string</span>)</span> <span class="params">(*AccessGateway, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> username != <span class="string">"Yu"</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"Username not enough permissions"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">"[%s] login into access gate wasy......\n"</span>, username)</span><br><span class="line">   <span class="keyword">return</span> &amp;AccessGateway&#123;&amp;VM&#123;&#125;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ag *AccessGateway)</span> <span class="title">Read</span><span class="params">()</span></span> &#123;</span><br><span class="line">   ag.v.Read()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ag *AccessGateway)</span> <span class="title">Write</span><span class="params">()</span></span> &#123;</span><br><span class="line">   ag.v.Write()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> accessGateway, err = NewAccessGateWay(<span class="string">"Yu"</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"Login into access gateway meet err! %v"</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   accessGateway.Write()</span><br><span class="line">   accessGateway.Read()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>输出结果如下:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">Yu</span>] login into access gate wasy......</span><br><span class="line">Permission to write....</span><br><span class="line">Permission to Read.....</span><br><span class="line"></span><br><span class="line"><span class="keyword">Process</span> finished with <span class="keyword">exit</span> code <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/category/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/singleton/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="./test.png" alt="test"></p>
<p>单例模式是我们平常开发中用的最多设计模式之一，单例有很多级别上的，例如函数上的单例，进程上的单例，下面讲的是代码中的单例，只要了解单例的思想即可，语言知识实现工具，下面讲解如下几种类型单例模式</p>
<ul>
<li>饿汉模式</li>
<li>懒汉模式</li>
<li>懒汉模式(加锁)</li>
<li>懒汉模式(双重检查加锁)</li>
<li>sync.Once实现</li>
</ul>
<p>相关代码如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SingleTon <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> singleTon *SingleTon</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="comment">//懒汉模式</span></span><br><span class="line"><span class="comment">//还有一种饿汉式，就是一开始就初始化singleTon,实现如下</span></span><br><span class="line"><span class="comment">//func init() &#123;</span></span><br><span class="line"><span class="comment">// singleTon = &amp;SingleTon&#123;&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSingleTon</span><span class="params">()</span> *<span class="title">SingleTon</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> singleTon == <span class="literal">nil</span> &#123;</span><br><span class="line">      singleTon = &amp;SingleTon&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> singleTon</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒汉加锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSingleTonByLock</span><span class="params">()</span> *<span class="title">SingleTon</span></span> &#123;</span><br><span class="line">   mu.Lock()</span><br><span class="line">   <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> singleTon == <span class="literal">nil</span> &#123;</span><br><span class="line">      singleTon = &amp;SingleTon&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> singleTon</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒汉加检查锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSingleTonByLock2</span><span class="params">()</span> *<span class="title">SingleTon</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> singleTon == <span class="literal">nil</span> &#123;</span><br><span class="line">      mu.Lock()</span><br><span class="line">      <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> singleTon == <span class="literal">nil</span> &#123;</span><br><span class="line">         singleTon = &amp;SingleTon&#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> singleTon</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过sync.Once实现</span></span><br><span class="line"><span class="comment">// 看过Once包的知道，实现很简单通过加锁实现，通过done标记位来判断，运行过一次通过原子操作将done置为1</span></span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSingleTonByOnce</span><span class="params">()</span> *<span class="title">SingleTon</span></span> &#123;</span><br><span class="line">   once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      singleTon = &amp;SingleTon&#123;&#125;</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> singleTon</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
